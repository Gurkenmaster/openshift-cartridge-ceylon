<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>Range.ceylon</title><link href='.resources/favicon.ico' rel='shortcut icon'/>
<link href='.resources/shCore.css' rel='stylesheet' type='text/css'/>
<link href='.resources/shThemeDefault.css' rel='stylesheet' type='text/css'/>
<script type='text/javascript'>var resourceBaseUrl = '.resources/'</script><script src='.resources/jquery-1.8.2.min.js' type='text/javascript'></script><script src='.resources/shCore.js' type='text/javascript'></script><script src='.resources/shAutoloader.js' type='text/javascript'></script><script src='.resources/shBrushCeylon.js' type='text/javascript'></script><script src='.resources/ceylondoc.js' type='text/javascript'></script></head><body><pre class='brush: ceylon'>&quot;Represents the range of totally ordered, ordinal values 
 generated by two endpoints of type `Ordinal` and 
 `Comparable`. If the first value is smaller than the
 last value, the range is increasing. If the first value
 is larger than the last value, the range is decreasing.
 If the two values are equal, the range contains exactly
 one element. The range is always nonempty, containing 
 at least one value.
 
 A range may be produced using the `..` operator:
 
     for (i in min..max) { ... }
     if (char in &apos;A&apos;..&apos;Z&apos;) { ... }
 &quot;
by (&quot;Gavin&quot;)
shared final class Range&lt;Element&gt;(first, last) 
        extends Object() 
        satisfies [Element+] &amp; 
                  Cloneable&lt;Range&lt;Element&gt;&gt;
        given Element satisfies Ordinal&lt;Element&gt; &amp; 
                                Comparable&lt;Element&gt; { 
    
    &quot;The start of the range.&quot;
    shared actual Element first;
    
    &quot;The end of the range.&quot;
    shared actual Element last;
    
    shared actual String string =&gt; 
            first.string + &quot;..&quot; + last.string;
    
    &quot;Determines if the range is decreasing.&quot;
    shared Boolean decreasing =&gt; last&lt;first; 
    
    Element next(Element x) =&gt;
            decreasing then x.predecessor 
                    else x.successor;

    &quot;The nonzero number of elements in the range.&quot;
    shared actual Integer size {
    	if (is Enumerable&lt;Anything&gt; last, 
    	    is Enumerable&lt;Anything&gt; first) {
    		return (last.integerValue - 
    		        first.integerValue)
    		            .magnitude+1;
    	}
    	else {
    		variable Integer size = 1;
    		variable Element current=first;
    		while (current!=last) {
    			size++;
    			current = next(current);
    		}
            return size;
    	}
    }
    
    &quot;The index of the end of the range.&quot;
    shared actual Integer lastIndex =&gt; size-1; 
    
    &quot;The rest of the range, without the start of the
     range.&quot;
    shared actual Element[] rest {
        if (size==1) { return {}; }
        Element n = next(first);
        return n==last then {} else Range&lt;Element&gt;(n,last);
    }
    
    &quot;The element of the range that occurs `n` values after
     the start of the range. Note that this operation 
     is inefficient for large ranges.&quot;
    shared actual Element? get(Integer n) {
        //optimize this for numbers!
        variable Integer index=0;
        variable Element x=first;
        while (index&lt;n) {
            if (x==last) {
                return null;
            }
            else {
                ++index;
                x=next(x);
            }
        }
        return x;
    }
    
    &quot;An iterator for the elements of the range.&quot;
    shared actual Iterator&lt;Element&gt; iterator() {
        class RangeIterator()
                satisfies Iterator&lt;Element&gt; {
            variable Element|Finished current = first;
            shared actual Element|Finished next() {
                Element|Finished result = current;
                if (!is Finished curr = current) {
                    if (decreasing then curr&lt;=last else curr&gt;=last) {
                        current = finished;
                    } 
                    else {
                        current = outer.next(curr);
                    }
                }
                return result;
            }
            shared actual String string {
                return &quot;RangeIterator&quot;;
            }
        }
        return RangeIterator();
    }
    
    shared actual {Element+} by(Integer step) {
        &quot;step size must be greater than zero&quot;
        assert (step &gt; 0);
        if (step == 1) {
            return this;
        }
        if (is Integer first, is Integer last) {
            return integerRangeByIterable(this, step);
        }
        //assert (is {Element+} result = super.by(step));
        //return result;
        return super.by(step);
    }
    
    shared actual Integer count(Boolean selecting(Element element)) {
        variable value e = first;
        variable value c = 0;
        while (containsElement(e)) {
            if (selecting(e)) {
                c++;
            }
            e = next(e);
        }
        return c;
    }
    
    &quot;Determines if this range includes the given object.&quot;
    shared actual Boolean contains(Object element) {
        if (is Element element) {
            return containsElement(element);
        }
        else {
            return false;
        }
    }
    
    &quot;Determines if this range includes the given value.&quot;
    shared actual Boolean occurs(Anything element) {
        if (is Element element) {
            return containsElement(element);
        }
        else {
            return false;
        }
    }
    
    &quot;Determines if the range includes the given value.&quot;
    shared Boolean containsElement(Element x) =&gt;
            decreasing then x&lt;=first &amp;&amp; x&gt;=last
                    else x&gt;=first &amp;&amp; x&lt;=last;
    
    shared actual Boolean includes(List&lt;Anything&gt; sublist) {
        if (is Range&lt;Element&gt; sublist) {
            return includesRange(sublist);
        }
        else {
            return super.includes(sublist);
        }
    }
    
    &quot;Determines if this range includes the given range.&quot;
    shared Boolean includesRange(Range&lt;Element&gt; sublist) {
        return first&lt;=sublist.first&lt;=last &amp;&amp;
                first&lt;=sublist.last&lt;=last;
    }
    
    &quot;Determines if two ranges are the same by comparing
     their endpoints.&quot;
    shared actual Boolean equals(Object that) {
        if (is Range&lt;Object&gt; that) {
            //optimize for another Range
            return that.first==first &amp;&amp; that.last==last;
        }
        else {
            //it might be another sort of List
            return super.equals(that);
        }
    }
    
    &quot;Returns the range itself, since ranges are 
     immutable.&quot;
    shared actual Range&lt;Element&gt; clone =&gt; this;
    
    shared actual Range&lt;Element&gt;|Empty segment(
            Integer from, 
            Integer length) {
        if (length&lt;=0 || from&gt;lastIndex) {
            return {};
        }
        variable value x=first;
        variable value i=0;
        while (i++&lt;from) { x=next(x); }
        variable value y=x;
        variable value j=1;
        while (j++&lt;length &amp;&amp; y&lt;last) { y=next(y); }
        return Range&lt;Element&gt;(x, y);
    }
    
    shared actual Range&lt;Element&gt;|Empty span(
            Integer from, Integer to) {
        variable value toIndex=to;
        variable value fromIndex=from;
        if (toIndex&lt;0) {
            if (fromIndex&lt;0) {
                return {};
            }
            toIndex=0;
        }
        else if (toIndex&gt;lastIndex) {
            if (fromIndex&gt;lastIndex) {
                return {};
            }
            toIndex=lastIndex;
        }
        if (fromIndex&lt;0) {
            fromIndex=0;
        }
        else if (fromIndex&gt;lastIndex) {
            fromIndex=lastIndex;
        }
        variable value x=first;
        variable value i=0;
        while (i++&lt;fromIndex) { x=next(x); }
        variable value y=first;
        variable value j=0;
        while (j++&lt;toIndex) { y=next(y); }
        return Range&lt;Element&gt;(x, y);
    }
    
    shared actual Range&lt;Element&gt;|Empty spanTo(Integer to) {
        return to &lt; 0 then {} else span(0, to);
    }
    
    shared actual Range&lt;Element&gt;|Empty spanFrom(Integer from) {
        return span(from, size);
    }

    &quot;Reverse this range, returning a new range.&quot;
    shared actual Range&lt;Element&gt; reversed =&gt; Range(last,first);
    
    shared actual Range&lt;Element&gt;|Empty skipping(Integer skip) {
        variable value x=0;
        variable value e = first;
        while (x++&lt;skip) {
            e=next(e);
        }
        return containsElement(e) then Range(e, last) else {};
    }
    
    shared actual Range&lt;Element&gt;|Empty taking(Integer take) {
        if (take == 0) {
            return {};
        }
        variable value x=0;
        variable value e=first;
        while (++x&lt;take) {
            e=next(e);
        }
        return containsElement(e) then Range(first, e) else this;
    }

    &quot;Returns the range itself, since a Range cannot
     contain nulls.&quot;
    shared actual Range&lt;Element&gt; coalesced =&gt; this;
    
    &quot;Returns this range.&quot;
    shared actual Range&lt;Element&gt; sequence =&gt; this;
    
}
</pre></body></html>